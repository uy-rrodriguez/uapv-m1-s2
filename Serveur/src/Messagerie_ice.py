# -*- coding: utf-8 -*-
# **********************************************************************
#
# Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.6.3
#
# <auto-generated>
#
# Generated from file `Messagerie.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module AppMP3Player
_M_AppMP3Player = Ice.openModule('AppMP3Player')
__name__ = 'AppMP3Player'

if 'Chanson' not in _M_AppMP3Player.__dict__:
    _M_AppMP3Player.Chanson = Ice.createTempClass()
    class Chanson(object):
        """
        La structure Chanson représente l'objet qui sera échangé dans les messages IceStorm
        entre le méta-serveur et les mini-serveurs.
        """
        def __init__(self, nom='', artiste='', categorie='', path='', miniserveur=''):
            self.nom = nom
            self.artiste = artiste
            self.categorie = categorie
            self.path = path
            self.miniserveur = miniserveur

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.nom)
            _h = 5 * _h + Ice.getHash(self.artiste)
            _h = 5 * _h + Ice.getHash(self.categorie)
            _h = 5 * _h + Ice.getHash(self.path)
            _h = 5 * _h + Ice.getHash(self.miniserveur)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_AppMP3Player.Chanson):
                return NotImplemented
            else:
                if self.nom is None or other.nom is None:
                    if self.nom != other.nom:
                        return (-1 if self.nom is None else 1)
                else:
                    if self.nom < other.nom:
                        return -1
                    elif self.nom > other.nom:
                        return 1
                if self.artiste is None or other.artiste is None:
                    if self.artiste != other.artiste:
                        return (-1 if self.artiste is None else 1)
                else:
                    if self.artiste < other.artiste:
                        return -1
                    elif self.artiste > other.artiste:
                        return 1
                if self.categorie is None or other.categorie is None:
                    if self.categorie != other.categorie:
                        return (-1 if self.categorie is None else 1)
                else:
                    if self.categorie < other.categorie:
                        return -1
                    elif self.categorie > other.categorie:
                        return 1
                if self.path is None or other.path is None:
                    if self.path != other.path:
                        return (-1 if self.path is None else 1)
                else:
                    if self.path < other.path:
                        return -1
                    elif self.path > other.path:
                        return 1
                if self.miniserveur is None or other.miniserveur is None:
                    if self.miniserveur != other.miniserveur:
                        return (-1 if self.miniserveur is None else 1)
                else:
                    if self.miniserveur < other.miniserveur:
                        return -1
                    elif self.miniserveur > other.miniserveur:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_AppMP3Player._t_Chanson)

        __repr__ = __str__

    _M_AppMP3Player._t_Chanson = IcePy.defineStruct('::AppMP3Player::Chanson', Chanson, (), (
        ('nom', (), IcePy._t_string),
        ('artiste', (), IcePy._t_string),
        ('categorie', (), IcePy._t_string),
        ('path', (), IcePy._t_string),
        ('miniserveur', (), IcePy._t_string)
    ))

    _M_AppMP3Player.Chanson = Chanson
    del Chanson

if '_t_ListeChansons' not in _M_AppMP3Player.__dict__:
    _M_AppMP3Player._t_ListeChansons = IcePy.defineSequence('::AppMP3Player::ListeChansons', (), _M_AppMP3Player._t_Chanson)

if 'TopicChansonsManager' not in _M_AppMP3Player.__dict__:
    _M_AppMP3Player.TopicChansonsManager = Ice.createTempClass()
    class TopicChansonsManager(Ice.Object):
        """
        Cette interface représente un gestionnaire de chansons du côté mini-serveur.
        Le gestionnaire sera utilisé via IceStorm en tant que Publisher pour publier des messages.
        Les méthodes de l'interface sont les différents messages possibles. Pour l'instant :
        - ajouter une chanson
        - supprimer une chanson
        """
        def __init__(self):
            if Ice.getType(self) == _M_AppMP3Player.TopicChansonsManager:
                raise RuntimeError('AppMP3Player.TopicChansonsManager is an abstract class')

        def ice_ids(self, current=None):
            return ('::AppMP3Player::TopicChansonsManager', '::Ice::Object')

        def ice_id(self, current=None):
            return '::AppMP3Player::TopicChansonsManager'

        def ice_staticId():
            return '::AppMP3Player::TopicChansonsManager'
        ice_staticId = staticmethod(ice_staticId)

        def listerChansons(self, chansons, current=None):
            pass

        def adresseStreaming(self, ipClient, ip, port, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_AppMP3Player._t_TopicChansonsManager)

        __repr__ = __str__

    _M_AppMP3Player.TopicChansonsManagerPrx = Ice.createTempClass()
    class TopicChansonsManagerPrx(Ice.ObjectPrx):

        def listerChansons(self, chansons, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManager._op_listerChansons.invoke(self, ((chansons, ), _ctx))

        def begin_listerChansons(self, chansons, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManager._op_listerChansons.begin(self, ((chansons, ), _response, _ex, _sent, _ctx))

        def end_listerChansons(self, _r):
            return _M_AppMP3Player.TopicChansonsManager._op_listerChansons.end(self, _r)

        def adresseStreaming(self, ipClient, ip, port, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManager._op_adresseStreaming.invoke(self, ((ipClient, ip, port), _ctx))

        def begin_adresseStreaming(self, ipClient, ip, port, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManager._op_adresseStreaming.begin(self, ((ipClient, ip, port), _response, _ex, _sent, _ctx))

        def end_adresseStreaming(self, _r):
            return _M_AppMP3Player.TopicChansonsManager._op_adresseStreaming.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManagerPrx.ice_checkedCast(proxy, '::AppMP3Player::TopicChansonsManager', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_AppMP3Player.TopicChansonsManagerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::AppMP3Player::TopicChansonsManager'
        ice_staticId = staticmethod(ice_staticId)

    _M_AppMP3Player._t_TopicChansonsManagerPrx = IcePy.defineProxy('::AppMP3Player::TopicChansonsManager', TopicChansonsManagerPrx)

    _M_AppMP3Player._t_TopicChansonsManager = IcePy.defineClass('::AppMP3Player::TopicChansonsManager', TopicChansonsManager, -1, (), True, False, None, (), ())
    TopicChansonsManager._ice_type = _M_AppMP3Player._t_TopicChansonsManager

    TopicChansonsManager._op_listerChansons = IcePy.Operation('listerChansons', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_AppMP3Player._t_ListeChansons, False, 0),), (), None, ())
    TopicChansonsManager._op_adresseStreaming = IcePy.Operation('adresseStreaming', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_int, False, 0)), (), None, ())

    _M_AppMP3Player.TopicChansonsManager = TopicChansonsManager
    del TopicChansonsManager

    _M_AppMP3Player.TopicChansonsManagerPrx = TopicChansonsManagerPrx
    del TopicChansonsManagerPrx

if 'TopicCommandesManager' not in _M_AppMP3Player.__dict__:
    _M_AppMP3Player.TopicCommandesManager = Ice.createTempClass()
    class TopicCommandesManager(Ice.Object):
        """
        Cette interface représente un gestionnaire de chansons du côté méta-serveur.
        Le gestionnaire sera utilisé via IceStorm en tant que Publisher pour publier des messages.
        Les méthodes de l'interface sont les différents messages possibles. Pour l'instant :
        - jouer une chanson
        - mettre en pause une chanson
        - arrêter une chanson
        """
        def __init__(self):
            if Ice.getType(self) == _M_AppMP3Player.TopicCommandesManager:
                raise RuntimeError('AppMP3Player.TopicCommandesManager is an abstract class')

        def ice_ids(self, current=None):
            return ('::AppMP3Player::TopicCommandesManager', '::Ice::Object')

        def ice_id(self, current=None):
            return '::AppMP3Player::TopicCommandesManager'

        def ice_staticId():
            return '::AppMP3Player::TopicCommandesManager'
        ice_staticId = staticmethod(ice_staticId)

        def listerChansons(self, current=None):
            pass

        def jouerChanson(self, ipClient, c, current=None):
            pass

        def pauseChanson(self, ipClient, current=None):
            pass

        def arreterChanson(self, ipClient, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_AppMP3Player._t_TopicCommandesManager)

        __repr__ = __str__

    _M_AppMP3Player.TopicCommandesManagerPrx = Ice.createTempClass()
    class TopicCommandesManagerPrx(Ice.ObjectPrx):

        def listerChansons(self, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_listerChansons.invoke(self, ((), _ctx))

        def begin_listerChansons(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_listerChansons.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_listerChansons(self, _r):
            return _M_AppMP3Player.TopicCommandesManager._op_listerChansons.end(self, _r)

        def jouerChanson(self, ipClient, c, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_jouerChanson.invoke(self, ((ipClient, c), _ctx))

        def begin_jouerChanson(self, ipClient, c, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_jouerChanson.begin(self, ((ipClient, c), _response, _ex, _sent, _ctx))

        def end_jouerChanson(self, _r):
            return _M_AppMP3Player.TopicCommandesManager._op_jouerChanson.end(self, _r)

        def pauseChanson(self, ipClient, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_pauseChanson.invoke(self, ((ipClient, ), _ctx))

        def begin_pauseChanson(self, ipClient, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_pauseChanson.begin(self, ((ipClient, ), _response, _ex, _sent, _ctx))

        def end_pauseChanson(self, _r):
            return _M_AppMP3Player.TopicCommandesManager._op_pauseChanson.end(self, _r)

        def arreterChanson(self, ipClient, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_arreterChanson.invoke(self, ((ipClient, ), _ctx))

        def begin_arreterChanson(self, ipClient, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_arreterChanson.begin(self, ((ipClient, ), _response, _ex, _sent, _ctx))

        def end_arreterChanson(self, _r):
            return _M_AppMP3Player.TopicCommandesManager._op_arreterChanson.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManagerPrx.ice_checkedCast(proxy, '::AppMP3Player::TopicCommandesManager', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_AppMP3Player.TopicCommandesManagerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::AppMP3Player::TopicCommandesManager'
        ice_staticId = staticmethod(ice_staticId)

    _M_AppMP3Player._t_TopicCommandesManagerPrx = IcePy.defineProxy('::AppMP3Player::TopicCommandesManager', TopicCommandesManagerPrx)

    _M_AppMP3Player._t_TopicCommandesManager = IcePy.defineClass('::AppMP3Player::TopicCommandesManager', TopicCommandesManager, -1, (), True, False, None, (), ())
    TopicCommandesManager._ice_type = _M_AppMP3Player._t_TopicCommandesManager

    TopicCommandesManager._op_listerChansons = IcePy.Operation('listerChansons', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    TopicCommandesManager._op_jouerChanson = IcePy.Operation('jouerChanson', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_AppMP3Player._t_Chanson, False, 0)), (), None, ())
    TopicCommandesManager._op_pauseChanson = IcePy.Operation('pauseChanson', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), None, ())
    TopicCommandesManager._op_arreterChanson = IcePy.Operation('arreterChanson', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), None, ())

    _M_AppMP3Player.TopicCommandesManager = TopicCommandesManager
    del TopicCommandesManager

    _M_AppMP3Player.TopicCommandesManagerPrx = TopicCommandesManagerPrx
    del TopicCommandesManagerPrx

if 'TopicMiniserveursManager' not in _M_AppMP3Player.__dict__:
    _M_AppMP3Player.TopicMiniserveursManager = Ice.createTempClass()
    class TopicMiniserveursManager(Ice.Object):
        """
        Cette interface permet la notification du démarrage ou arrêt des miniserveurs.
        Les méthodes de l'interface sont les différents messages possibles. Pour l'instant :
        - indiquer le démarrage d'un nouveau miniserveur
        - indiquer l'arrêt d'un miniserveur existant
        """
        def __init__(self):
            if Ice.getType(self) == _M_AppMP3Player.TopicMiniserveursManager:
                raise RuntimeError('AppMP3Player.TopicMiniserveursManager is an abstract class')

        def ice_ids(self, current=None):
            return ('::AppMP3Player::TopicMiniserveursManager', '::Ice::Object')

        def ice_id(self, current=None):
            return '::AppMP3Player::TopicMiniserveursManager'

        def ice_staticId():
            return '::AppMP3Player::TopicMiniserveursManager'
        ice_staticId = staticmethod(ice_staticId)

        def enregistrerServeur(self, ip, nom, current=None):
            pass

        def supprimerServeur(self, ip, nom, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_AppMP3Player._t_TopicMiniserveursManager)

        __repr__ = __str__

    _M_AppMP3Player.TopicMiniserveursManagerPrx = Ice.createTempClass()
    class TopicMiniserveursManagerPrx(Ice.ObjectPrx):

        def enregistrerServeur(self, ip, nom, _ctx=None):
            return _M_AppMP3Player.TopicMiniserveursManager._op_enregistrerServeur.invoke(self, ((ip, nom), _ctx))

        def begin_enregistrerServeur(self, ip, nom, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicMiniserveursManager._op_enregistrerServeur.begin(self, ((ip, nom), _response, _ex, _sent, _ctx))

        def end_enregistrerServeur(self, _r):
            return _M_AppMP3Player.TopicMiniserveursManager._op_enregistrerServeur.end(self, _r)

        def supprimerServeur(self, ip, nom, _ctx=None):
            return _M_AppMP3Player.TopicMiniserveursManager._op_supprimerServeur.invoke(self, ((ip, nom), _ctx))

        def begin_supprimerServeur(self, ip, nom, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicMiniserveursManager._op_supprimerServeur.begin(self, ((ip, nom), _response, _ex, _sent, _ctx))

        def end_supprimerServeur(self, _r):
            return _M_AppMP3Player.TopicMiniserveursManager._op_supprimerServeur.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_AppMP3Player.TopicMiniserveursManagerPrx.ice_checkedCast(proxy, '::AppMP3Player::TopicMiniserveursManager', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_AppMP3Player.TopicMiniserveursManagerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::AppMP3Player::TopicMiniserveursManager'
        ice_staticId = staticmethod(ice_staticId)

    _M_AppMP3Player._t_TopicMiniserveursManagerPrx = IcePy.defineProxy('::AppMP3Player::TopicMiniserveursManager', TopicMiniserveursManagerPrx)

    _M_AppMP3Player._t_TopicMiniserveursManager = IcePy.defineClass('::AppMP3Player::TopicMiniserveursManager', TopicMiniserveursManager, -1, (), True, False, None, (), ())
    TopicMiniserveursManager._ice_type = _M_AppMP3Player._t_TopicMiniserveursManager

    TopicMiniserveursManager._op_enregistrerServeur = IcePy.Operation('enregistrerServeur', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), None, ())
    TopicMiniserveursManager._op_supprimerServeur = IcePy.Operation('supprimerServeur', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), None, ())

    _M_AppMP3Player.TopicMiniserveursManager = TopicMiniserveursManager
    del TopicMiniserveursManager

    _M_AppMP3Player.TopicMiniserveursManagerPrx = TopicMiniserveursManagerPrx
    del TopicMiniserveursManagerPrx

# End of module AppMP3Player
