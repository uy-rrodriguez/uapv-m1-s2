# -*- coding: utf-8 -*-
# **********************************************************************
#
# Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.6.3
#
# <auto-generated>
#
# Generated from file `Messagerie.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module AppMP3Player
_M_AppMP3Player = Ice.openModule('AppMP3Player')
__name__ = 'AppMP3Player'

if 'Chanson' not in _M_AppMP3Player.__dict__:
    _M_AppMP3Player.Chanson = Ice.createTempClass()
    class Chanson(object):
        """
        La structure Chanson représente l'objet qui sera échangé dans les messages IceStorm
        entre le méta-serveur et les mini-serveurs.
        """
        def __init__(self, nom='', artiste='', categorie='', ipServeur='', path=''):
            self.nom = nom
            self.artiste = artiste
            self.categorie = categorie
            self.ipServeur = ipServeur
            self.path = path

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.nom)
            _h = 5 * _h + Ice.getHash(self.artiste)
            _h = 5 * _h + Ice.getHash(self.categorie)
            _h = 5 * _h + Ice.getHash(self.ipServeur)
            _h = 5 * _h + Ice.getHash(self.path)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_AppMP3Player.Chanson):
                return NotImplemented
            else:
                if self.nom is None or other.nom is None:
                    if self.nom != other.nom:
                        return (-1 if self.nom is None else 1)
                else:
                    if self.nom < other.nom:
                        return -1
                    elif self.nom > other.nom:
                        return 1
                if self.artiste is None or other.artiste is None:
                    if self.artiste != other.artiste:
                        return (-1 if self.artiste is None else 1)
                else:
                    if self.artiste < other.artiste:
                        return -1
                    elif self.artiste > other.artiste:
                        return 1
                if self.categorie is None or other.categorie is None:
                    if self.categorie != other.categorie:
                        return (-1 if self.categorie is None else 1)
                else:
                    if self.categorie < other.categorie:
                        return -1
                    elif self.categorie > other.categorie:
                        return 1
                if self.ipServeur is None or other.ipServeur is None:
                    if self.ipServeur != other.ipServeur:
                        return (-1 if self.ipServeur is None else 1)
                else:
                    if self.ipServeur < other.ipServeur:
                        return -1
                    elif self.ipServeur > other.ipServeur:
                        return 1
                if self.path is None or other.path is None:
                    if self.path != other.path:
                        return (-1 if self.path is None else 1)
                else:
                    if self.path < other.path:
                        return -1
                    elif self.path > other.path:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_AppMP3Player._t_Chanson)

        __repr__ = __str__

    _M_AppMP3Player._t_Chanson = IcePy.defineStruct('::AppMP3Player::Chanson', Chanson, (), (
        ('nom', (), IcePy._t_string),
        ('artiste', (), IcePy._t_string),
        ('categorie', (), IcePy._t_string),
        ('ipServeur', (), IcePy._t_string),
        ('path', (), IcePy._t_string)
    ))

    _M_AppMP3Player.Chanson = Chanson
    del Chanson

if 'TopicChansonsManager' not in _M_AppMP3Player.__dict__:
    _M_AppMP3Player.TopicChansonsManager = Ice.createTempClass()
    class TopicChansonsManager(Ice.Object):
        """
        Cette interface représente un gestionnaire de chansons du côté mini-serveur.
        Le gestionnaire sera utilisé via IceStorm en tant que Publisher pour publier des messages.
        Les méthodes de l'interface sont les différents messages possibles. Pour l'instant :
        - ajouter une chanson
        - supprimer une chanson
        """
        def __init__(self):
            if Ice.getType(self) == _M_AppMP3Player.TopicChansonsManager:
                raise RuntimeError('AppMP3Player.TopicChansonsManager is an abstract class')

        def ice_ids(self, current=None):
            return ('::AppMP3Player::TopicChansonsManager', '::Ice::Object')

        def ice_id(self, current=None):
            return '::AppMP3Player::TopicChansonsManager'

        def ice_staticId():
            return '::AppMP3Player::TopicChansonsManager'
        ice_staticId = staticmethod(ice_staticId)

        def ajouterChanson(self, c, current=None):
            pass

        def supprimerChanson(self, c, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_AppMP3Player._t_TopicChansonsManager)

        __repr__ = __str__

    _M_AppMP3Player.TopicChansonsManagerPrx = Ice.createTempClass()
    class TopicChansonsManagerPrx(Ice.ObjectPrx):

        def ajouterChanson(self, c, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManager._op_ajouterChanson.invoke(self, ((c, ), _ctx))

        def begin_ajouterChanson(self, c, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManager._op_ajouterChanson.begin(self, ((c, ), _response, _ex, _sent, _ctx))

        def end_ajouterChanson(self, _r):
            return _M_AppMP3Player.TopicChansonsManager._op_ajouterChanson.end(self, _r)

        def supprimerChanson(self, c, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManager._op_supprimerChanson.invoke(self, ((c, ), _ctx))

        def begin_supprimerChanson(self, c, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManager._op_supprimerChanson.begin(self, ((c, ), _response, _ex, _sent, _ctx))

        def end_supprimerChanson(self, _r):
            return _M_AppMP3Player.TopicChansonsManager._op_supprimerChanson.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_AppMP3Player.TopicChansonsManagerPrx.ice_checkedCast(proxy, '::AppMP3Player::TopicChansonsManager', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_AppMP3Player.TopicChansonsManagerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::AppMP3Player::TopicChansonsManager'
        ice_staticId = staticmethod(ice_staticId)

    _M_AppMP3Player._t_TopicChansonsManagerPrx = IcePy.defineProxy('::AppMP3Player::TopicChansonsManager', TopicChansonsManagerPrx)

    _M_AppMP3Player._t_TopicChansonsManager = IcePy.defineClass('::AppMP3Player::TopicChansonsManager', TopicChansonsManager, -1, (), True, False, None, (), ())
    TopicChansonsManager._ice_type = _M_AppMP3Player._t_TopicChansonsManager

    TopicChansonsManager._op_ajouterChanson = IcePy.Operation('ajouterChanson', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_AppMP3Player._t_Chanson, False, 0),), (), None, ())
    TopicChansonsManager._op_supprimerChanson = IcePy.Operation('supprimerChanson', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_AppMP3Player._t_Chanson, False, 0),), (), None, ())

    _M_AppMP3Player.TopicChansonsManager = TopicChansonsManager
    del TopicChansonsManager

    _M_AppMP3Player.TopicChansonsManagerPrx = TopicChansonsManagerPrx
    del TopicChansonsManagerPrx

if 'TopicCommandesManager' not in _M_AppMP3Player.__dict__:
    _M_AppMP3Player.TopicCommandesManager = Ice.createTempClass()
    class TopicCommandesManager(Ice.Object):
        """
        Cette interface représente un gestionnaire de chansons du côté méta-serveur.
        Le gestionnaire sera utilisé via IceStorm en tant que Publisher pour publier des messages.
        Les méthodes de l'interface sont les différents messages possibles. Pour l'instant :
        - jouer une chanson
        - mettre en pause une chanson
        - arrêter une chanson
        """
        def __init__(self):
            if Ice.getType(self) == _M_AppMP3Player.TopicCommandesManager:
                raise RuntimeError('AppMP3Player.TopicCommandesManager is an abstract class')

        def ice_ids(self, current=None):
            return ('::AppMP3Player::TopicCommandesManager', '::Ice::Object')

        def ice_id(self, current=None):
            return '::AppMP3Player::TopicCommandesManager'

        def ice_staticId():
            return '::AppMP3Player::TopicCommandesManager'
        ice_staticId = staticmethod(ice_staticId)

        def jouerChanson(self, c, current=None):
            pass

        def pauseChanson(self, c, current=None):
            pass

        def arreterChanson(self, c, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_AppMP3Player._t_TopicCommandesManager)

        __repr__ = __str__

    _M_AppMP3Player.TopicCommandesManagerPrx = Ice.createTempClass()
    class TopicCommandesManagerPrx(Ice.ObjectPrx):

        def jouerChanson(self, c, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_jouerChanson.invoke(self, ((c, ), _ctx))

        def begin_jouerChanson(self, c, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_jouerChanson.begin(self, ((c, ), _response, _ex, _sent, _ctx))

        def end_jouerChanson(self, _r):
            return _M_AppMP3Player.TopicCommandesManager._op_jouerChanson.end(self, _r)

        def pauseChanson(self, c, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_pauseChanson.invoke(self, ((c, ), _ctx))

        def begin_pauseChanson(self, c, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_pauseChanson.begin(self, ((c, ), _response, _ex, _sent, _ctx))

        def end_pauseChanson(self, _r):
            return _M_AppMP3Player.TopicCommandesManager._op_pauseChanson.end(self, _r)

        def arreterChanson(self, c, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_arreterChanson.invoke(self, ((c, ), _ctx))

        def begin_arreterChanson(self, c, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManager._op_arreterChanson.begin(self, ((c, ), _response, _ex, _sent, _ctx))

        def end_arreterChanson(self, _r):
            return _M_AppMP3Player.TopicCommandesManager._op_arreterChanson.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_AppMP3Player.TopicCommandesManagerPrx.ice_checkedCast(proxy, '::AppMP3Player::TopicCommandesManager', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_AppMP3Player.TopicCommandesManagerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::AppMP3Player::TopicCommandesManager'
        ice_staticId = staticmethod(ice_staticId)

    _M_AppMP3Player._t_TopicCommandesManagerPrx = IcePy.defineProxy('::AppMP3Player::TopicCommandesManager', TopicCommandesManagerPrx)

    _M_AppMP3Player._t_TopicCommandesManager = IcePy.defineClass('::AppMP3Player::TopicCommandesManager', TopicCommandesManager, -1, (), True, False, None, (), ())
    TopicCommandesManager._ice_type = _M_AppMP3Player._t_TopicCommandesManager

    TopicCommandesManager._op_jouerChanson = IcePy.Operation('jouerChanson', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_AppMP3Player._t_Chanson, False, 0),), (), None, ())
    TopicCommandesManager._op_pauseChanson = IcePy.Operation('pauseChanson', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_AppMP3Player._t_Chanson, False, 0),), (), None, ())
    TopicCommandesManager._op_arreterChanson = IcePy.Operation('arreterChanson', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_AppMP3Player._t_Chanson, False, 0),), (), None, ())

    _M_AppMP3Player.TopicCommandesManager = TopicCommandesManager
    del TopicCommandesManager

    _M_AppMP3Player.TopicCommandesManagerPrx = TopicCommandesManagerPrx
    del TopicCommandesManagerPrx

# End of module AppMP3Player
